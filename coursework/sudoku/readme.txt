DOMAINS:
For every cell in the sudoku it is assigned a domain. This defines every possible value that could go into that cell.
The data type used for the domains is a set D={d1-d9} (d1-d9 can be non-existent), primary for the use of the discard method. Since a set is unordered and contains no duplicates, when the discard method is called it will remove all occurrences of the number. The other benefit over a list is that calling discard with a value not contained within the set will not throw an error, unlike using the remove method on a list which throws ValueError. This allows for much simpler, clearer and robust code to be written.
Initially the domains contain the numbers {1-9}. When a value is assigned to the cell the domain becomes empty {}. If the domain only contains one value, then it is guaranteed and an algorithm detects this and places in the number. If a domain is empty {} yet the cell has a value of 0 then the sudoku is invalid and backtracking is required.
Domains are filled out by very simply removing any values that appear in a row, column or sub-block from all domains within that row, column and sub-block.

SUDOKU OBJECTS:
Every sudoku is represented as an object that stores both the 9x9 grid and the domains for each cell. It also contains many methods to manipulate both the grid and domains. After the initial sudoku has been created all deeper partial states are generated by copying the object, adding in a value then returning that newly created object. The search space is made up of these sudoku objects.
The goal state is when every value in the grid is not equal to 0 and the sudoku is not invalid. An invalid state is when there are two values within a row, column or sub-block that are equal.

CONTRATINT SATISFACTION DEPTH FIRST SEARCH:
The primary method to solving the sudokus is a depth first search with constraint satisfaction. It starts with a partial sudoku that was passed into the solver. If the initial sudoku is not consistent then an invalid solution will be passed back instantly. Otherwise, it will continue with the depth first search. To determine the next partial states to explore it begins by selecting a cells domain as explained in the heurists below. It will then generate the new sudoku object and test if it is the solution. If it is not the solution and there are still possible moves it will recursively call the depth first search function with the new object. When the algorithm hits a dead end, it will fall back through the operations stack until it reaches a sudoku which has an untested domain value. If every value in a domain has been tested with no possible solutions, then an invalid sudoku is returned.
Alone this algorithm is not very fast but in combination with other methods to solve a sudoku when there is guaranteed and unique values to be added it can solve sudokus in under a second.

HEURISTICS:
The heuristic used to choose the starting cell is Minimum Remaining Value. That is, it chooses the domain that has the fewest possible values. Due to a domain of length 1 being a guaranteed answer, the shortest domain is of length 2. This reduces the branching factor of the depth first search significantly.
No heuristic was used to determine the order that these domains should be explored in as the extra processing time to determine the best order is longer than the time it would save to search them randomly.

GUARANTEED VALUES:
One of the ways to speed up the solving of a sudoku is whenever a domain has length of 1 add that value into the grid. This process of adding a value in is considerably faster than creating an entirely new object and partial state just for one value that is already known.

UNIQUE VALUES:
The other main way that humans solve sudokus is to find unique values. Looking at the context of a row, if the domains of the three cells that are not assigned are {3, 2, 7}, {3, 2} and {9, 2, 3} then the value of 7 and 9 are guaranteed answers. The algorithm for finding these starts by creating two new lists. These lists contain 27 empty sets each. The set is the best data type for this as it does not allow duplicates. The first list contains every value in a row, column or sub-block that appears at least once: F = {d1-d9}. The second list contains every value in a row, column or sub-block that appears at least twice: S = {d1-d9}. When you remove all values in the second set S from the first set F, F/S you get a set that contains all values that only appear once within a row, column or sub-block. The algorithm will then determine where these values originated from and add in those numbers.
This brings the solve time from a few seconds to a few tenths of a second. The main reason for this is that once a certain number of values have been guessed by the constraint satisfaction this algorithm will then fill out the rest of the grid without creating new objects reaching a solution or invalid state significantly faster.
